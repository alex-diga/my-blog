# 浏览器基本知识

浏览器工作原理、浏览器安全、浏览器性能监控和分析。

## 浏览器缓存

缓存是性能优化中非常重要的一环，浏览器缓存机制对开发也是非常重要的知识点。

- 强缓存
- 协商缓存
- 缓存位置

### 强缓存

浏览器的缓存作用分为两种情况，一种是需要发送`HTTP`请求，一种是不需要发送

首先是检查`强缓存`，这个阶段不需要发送`HTTP`请求

在`HTTP/1.0`和`HTTP/1.1`当中，字段是不同的，`HTTP/1.0`使用`Expries`，而`HTTP/1.1`使用`Cache-Contorl`。

#### Expries

`Expries`即过期时间，存在于服务器返回的相应头中，告诉浏览器在这个过期时间之前可以直接从缓存中获取数据，无需再次请求

`Expires: Wed, 22 Nov 2021 08:41:00 GMT`表示资源在`2021年11月22号8点41分`过期，过期了就得向服务端发请求。

但是`Expries`有潜在风险，那就是`服务器的时间和浏览器的时间可能并不一致`，那服务器返回的过期时间可能是不准确的，因此在`HTTP/1.1`版本中被抛弃。

#### Cache-Contorl

`Cache-Contorl`和`Expries`本质的区别是没有采用`具体的过期时间点`，而是采用过期时长来控制缓存。

比如`Cache-Control:max-age=3600`表示这个响应返回后在`3600秒`内可以直接使用缓存。

`Cache-Contorl`可以由多个属性组合成非常多的指令，完成更多场景的缓存判断，关键属性列表：

|   属性   |                      作用                      |      示例      |
| :------: | :--------------------------------------------: | :------------: |
| max-age  |     浏览器在响应返回后的时间内直接使用缓存     | max-age=604800 |
|  public  |          客户端和代理服务器都可以缓存          |                |
| private  |   只有浏览器能缓存，中间的代理服务器不能缓存   |                |
| no-cache | 跳过当前缓存，发送 HTTP 请求，进入协商缓存阶段 |                |
| no-store |              不进行任何形式的缓存              |                |
| s-maxage |      s-maxage 是针对代理服务器的缓存时间       |  s-maxage=60   |

`public`是因为一个请求可能会经过不同的代理服务器才能到达最后目标服务器，不仅浏览器可以缓存数据，中间任何代理节点也可以缓存。

> 当`Expries`和`Cache-Contorl`同时存在时，会优先考虑`Cache-Contorl`。

### 协商缓存

强缓存失效后，进入协商缓存阶段。浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，有服务器根据这个`tag`，来决定是否使用缓存，这就是协商缓存。

缓存 tag 分为 2 种：`Last-Modified`和`ETag`。两者各有优劣，不存在绝对优势。

#### Last-Modified

`Last-Modified`即最后修改时间。

1. 在浏览器第一次给服务器发送请求后，服务器会在响应头加上`Last-Modified`这个字段
2. 浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值就是服务器传来的`Last-Modified`的最后修改时间
3. 服务器拿到请求头的`If-Modified-Since`字段的时间，会和服务器中的`该资源的最后修改时间`做对比：
   - 如果请求头中的这个值小于最后修改时间，说明是时候更新了，服务器返回新资源，跟常规的`HTTP`请求响应流程一致
   - 否则返回`304`，告诉浏览器直接使用缓存

#### ETag

`ETag`是服务器根据当前文件的内容，给文件生成的唯一标识，只要文件内容有改动，这个值就会变。

1. 服务器通过相应头把这个值`ETag`发给浏览器
2. 浏览器接收到`ETag`的值，会在下次请求时，将这个值作为`If-None-Match`字段的值，并放到请求头里发送给服务器
3. 服务器接收到`If-None-Match`后，会跟服务器上该资源的`ETag`做对比：

- 如果两者不一样，说明需要更新了，返回新的资源，跟常规的`HTTP`请求响应流程一致
- 否则返回`304`，告诉浏览器直接使用缓存

#### 两者对比

1. 在性能上，`Last-Modified`优于`ETag`。`Last-Modified`仅仅记录一个时间点，`ETag`需要根据文件的具体内容生成哈希值。
2. 在精准度上，`ETag`优于`Last-Modified`。`ETag`是根据文件内容给资源标识，因此能准确感知资源的改动，而`Last-Modified`在一些特殊情况下并不能感知资源变化，主要有 2 种情况：
   - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效
   - `Last-Modified`能够感知的单位时间是秒，如果文件在 1 秒内改动多次，那么`Last-Modified`并没有体现出修改

> 如果两种方式都支持的话，服务器会优先考虑`ETag`。

### 缓存位置

当强缓存命中和协商缓存中服务器返回`304`的时候，直接从缓存中获取资源。

浏览器中缓存位置有 4 种，按照优先级从高到低排序是：

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

#### Service Worker

`Service Worker`借鉴`Web Worker`的思路，让`JS`运行在主线程之外，由于它脱离了浏览器窗体无法直接访问`DOM`，但是它仍然能够帮助我们完成很多有用的功能，比如`离线缓存`、`消息推送`和`网络代理`等，其中`离线缓存`就是`Service worker Cache`。

#### Memory Cache 和 Disk Cache

`Memory Cache`指的是内存缓存，从效率上它是最快的，但是从存活时间上来讲又是最短的，当渲染结束后内存缓存也就不存在了。
`Disk Cache`是存储在磁盘的缓存，从存取效率上比内存缓存慢，但优势是存储容量和存储时长。

浏览器决定将资源放进内存或者磁盘策略：

- 比较大的 JS、CSS 文件会直接放进磁盘，反之丢进内存
- 内存使用率比较高时，文件优先进入磁盘

#### Push Cache

即推送缓存，这是浏览器缓存最后一道防线，它是`HTTP/2`的内容，现在应用不广泛，但随着`HTTP/2`推广，他的应用会越来越广泛。

### 总结

浏览器缓存机制总结：

首先通过`Cache-Control`验证强缓存是否有效：

- 如果强缓存有效，直接使用缓存
- 否则进入协商缓存，即发送`HTTP`请求，服务器通过请求头的`If-None-Match`或者`If-Modified-Since`字段字段检查资源是否更新
  - 若资源更新，返回资源和 200 状态码
  - 否则返回 304，浏览器直接从缓存中获取资源

## 浏览器本地存储

浏览器本地存储主要分为：`Cookie`、`WebStorage`和`IndexedDB`，其中`WebStorage`分为`localStorage`和`sessionStorage`

### Cookie

`Cookie`最开始设计出来并不是用来做本地存储，而是为了弥补`HTTP`状态管理上的不足
`HTTP`协议是一个无状态协议，`Cookie`本质上是浏览器存储的一个很小的文本文件，内部以键值对的方式来存储，向同一个域名下发送请求时，都会携带上相同的`Cookie`，服务器拿到`Cookie`进行解析，便能拿到客户端状态.

`Cookie`的缺陷：

1. 容量缺陷，`Cookie`的容量上限仅为`4KB`，只能用来存储少量信息
2. 性能缺陷，`Cookie`紧跟域名，不管域名下面的任一地址是否需要此`Cookie`，请求都会携带上完整的`Cookie`，这样随着请求数的增多，会造成严重的性能浪费，因为请求携带了很多不必要的内容
3. 安全缺陷，由于`Cookie`以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列篡改，在`Cookie`有效期内重新发送给服务器。另外在`HttpOnly`为`false`时， `Cookie` 信息能直接通过`JS`获取

### localStorage

`localStorage`跟`Cookie`一样，针对同一个域名下会存储相同的一段`localStorage`

`localStorage`跟`Cookie`区别：

1. 容量，`localStorage`的容量上限为`5M`，当然这个`5M`是针对一个域名的，因此对于一个域名是持久存储的
2. `localStorage`只存在客户端，默认不参与服务器的通信，这样避免了`Cookie`带来的性能问题和安全问题
3. 接口封装，通过`localStorage`暴露全局，并通过`setItem`和`getItem`等方法进行操作

#### 操作

```js
const obj = { name: "tom", age: 12 };
localStorage.setItem("name", "tom");
localStorage.setItem("info", JSON.stringify(obj));

const name = localStorage.getItem("name"); // tom
const info = JSON.parse(localStorage.getItem("info")); //  { name: "tom", age: 12 }
```

> `localStorage`存储的都是字符串，如果是存储对象，需要调用`JSON.stringify`方法，再通过`JSON.parse`来解析成对象

#### 应用场景

利用`localStorage`较大的容量和持久特性，可以利用`localStorage`存储一些内容稳定的资源，比如官网的`logo`，存储`Base64`格式的图片资源

### sessionStorage

`sessionStorage`和`localStorage`有一致的：

1. 容量，容量上限都为`5M`
2. 只存在客户端，默认不参与服务器的通信
3. 接口封装，存储方式、操作方式一样

`sessionStorage`和`localStorage`本质区别是，`sessionStorage`是会话级别的存储，并不是持久化存储，会话结束即页面关闭，`sessionStorage`也不存在了

#### 应用场景

1. 可以用`sessionStorage`对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失
2. 可以存储本次浏览记录，如果关闭页面后不需要这些记录，`sessionStorage`适合保存这些场景的数据

### IndexedDB

`IndexedDB`是运行在浏览器中的`非关系型数据库`，本质上是数据库，理论上容量是无上限的

`IndexedDB` 的重要特性有：

1. 支持事务
2. 存储二进制数据
3. 键值对存储，内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储
4. 异步操作，数据库的读写属于 I/O 操作，浏览器对异步 I/O 提供了支持
5. 受同源策略限制，无法访问跨域的数据库

### 总结

1. Cookie 不适合存储，并且存在很多缺陷
2. Web Storage 包括 sessionStorage 和 localStorage，默认不参与和服务器的通信
3. IndexedDB 为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口

## XSS 攻击

`XSS`全称是`Cross Site Scripting`即(`跨站脚本`),为了和`CSS`区分，故叫做`XSS`。
`XSS`攻击是指浏览器中执行恶意脚本（无论是跨域还是同域），从而拿到用户的信息并进行操作。

这些操作一般可以玩成以下事情：

1. 窃取`Cookie`
2. 监听用户行为，比如输入账号密码后直接发送到黑客服务器
3. 修改 DOM 伪造登录表单
4. 在页面生成浮窗广告

通常情况下，`XSS`攻击的实现有三种方式：`存储型`、`反射型`和`文档型`

### 存储型

`存储型`是将恶意脚本存储起来，存储型的`XSS`将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果

### 反射型

`反射型`是指恶意脚本作为网络请求的一部分

#### 示例

```js
http://abc.com?q=<script>alert("你完蛋了")</script>
```

在服务器端会拿到 q 参数，然后将内容返回浏览器端，浏览器将这些内容作为 HTML 的一部分进行解析，然后发现是一个脚本，直接执行，这样就被攻击了
因为`反射型`脚本是通过作为网络请求的参数，进过服务器，然后再反射到 HTML 文档中执行解析，和`存储型`不一样的是，服务器并不会存储这些恶意脚本。

### 文档型

`文档型`的`XSS`攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程中劫持到网络数据包，然后修改里面的 html 文档，劫持方式包括：`WIFI路由器劫持`和`本地恶意软件`。

### 防范措施

三种`XSS`攻击的原理都是让恶意脚本能够在浏览器中执行。
防范`XSS`攻击就是避免这些恶意脚本代码的执行

#### 转码过滤

不相信任何用户的输入，无论是前端还是服务端，都要对用户的输入进行转码或过滤

##### 转码

```js
<script>alert('你完蛋了')</script>

//转码后
&lt;script&gt;alert(&#39;你完蛋了&#39;)&lt;/script&gt;
```

##### 过滤

利用关键词过滤的方式，将 script 标签给删除

```js
<span>XSS攻击</span>
<script>alert('你完蛋了')</script>

//过滤后
<span>XSS攻击</span>
```

#### 利用 CSP

`CSP`即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源

通过`CSP`可以完成以下功能：

1. 限制其他域下的资源加载
2. 禁止向其他域提交数据
3. 提供上报机制，能帮助我们发现 XSS 攻击

#### 利用 HttpOnly

很多`XSS`攻击脚本都是用来窃取`Cookie`，而设置`Cookie`的`HttpOnly`属性后，`javaScript`便无法读取`Cookie`的值，这样也能很好防范`XSS`攻击

### 总结

`XSS`攻击是指浏览器中执行恶意脚本，然后拿到用户信息进行操作，主要分为存储型、反射型和文档型。

防范措施：

1. 不要相信用户的任何输入，对输入内容进行转码或过滤，不让其执行
2. 利用 CSP，利用 Cookie 的 HttpOnly 属性

## CSRF 攻击

CSRF(Cross-site request forgery)，即跨站请求伪造。指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求

### 自动发送 GET 请求

黑客网页里面可能会有一段这样的代码

```js
<img src="https://xxx.com/info?user=hhh&count=100">
```

进入黑客页面后自动发送`get`请求，值得注意的是，这个请求会自动带上关于`xxx.com`的`cookie`信息（假设用户已在 xxx.com 中登录过）

假如服务端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的操作，可以是转账汇款以及其他恶意操作

### 自动发送 POST 请求

黑客可以自己填写一个表单，写了一段自动提交的脚本

```js
<form id='hacker-form' action="https://xxx.com/info" method="POST">
  <input type="hidden" name="user" value="hhh" />
  <input type="hidden" name="count" value="100" />
</form>
<script>document.getElementById('hacker-form').submit();</script>
```

同样也会携带上相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能

### 诱导点击发送 GET 请求

在黑客的网站上，可能会放上一个链接，驱使用户来点击

```js
<a href="https://xxx/info?user=hhh&count=100" taget="_blank">
  点击进入修仙世界
</a>
```

点击后，自动发送 get 请求，接下来和`自动发送 GET`请求同理

### 原理

这就是`CSRF`攻击原理，和`XSS`攻击对比，`CSRF`攻击并不需要将恶意代码注入用户当前页面的`html`文档中，而是跳转到新的页面，利用服务器的`验证漏洞`和`用户之前的登录状态`来模拟用户进行操作

### 防范措施

#### 利用 Cookie 的 SameSite 属性

`CSRF`攻击中重要的一环是自动发送目标站点下的 `Cookie`，然后就是利用`Cookie`模拟用户的身份，因此`Cookie`是防范的重点

`Cookie`当中有一个关键属性`SameSite`，可以对请求中的 Cookie 的携带作一些限制

`SameSite`可以设置三个值：`Strict`、`Lax`和`None`

|  模式  |                                                            作用                                                            |
| :----: | :------------------------------------------------------------------------------------------------------------------------: |
| Strict | 浏览器完全禁止第三方请求携带 Cookie，比如请求 abc.com 网站只能在 abc.com 域名当中请求才能携带 cookie，在其他网站请求都不能 |
|  Lax   |                    只能在 get 方法提交表单和 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能                    |
|  None  |                                             默认模式，请求会自动携带上 Cookie                                              |

#### 验证来源战点

这就需要用到请求头中的两个字段：`Origin`和`Referer`

其中，`Origin`只包含域名信息，而`Referer`包含了具体的 URL 路径

但是，这两者都是可以伪造的，通过`Ajax`中自定义请求头即可，安全性略差

#### CSRF Token

`CSRF Token`原理：浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到要返回的页面中
然后浏览器如果要发送请求，就必须携带上这个字符串，然后服务器来验证是否合法，如果不合法则不予以相应。这个字段就是`CSRF Token`，通常第三方站点是无法拿到这个`CSRF Token`的，因此第三方请求就会被服务器给拒绝。

### 总结

`CSRF`即跨站请求伪造，指的是黑客诱导用户点击链接打开黑客的网页，然后黑客利用用户目前的登录状态发起跨站请求

`CSRF`攻击一般会有三种方式：

1. 自动 GET 请求
2. 自动 POST 请求
3. 诱导点击发送 GET 请求

防范措施：

1. 利用 Cookie 的 SameSite 属性
2. 验证来源站点
3. CSRF Token

## 参考

1. [神三元-浏览器灵魂之问](https://juejin.cn/post/6844904021308735502)
